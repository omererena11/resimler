<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=5, user-scalable=no"/>
<meta name="referrer" content="no-referrer"/>
<title>Viewer (True Anchor Zoom • Any Point)</title>
<style>
  html, body{
    margin:0; padding:0; height:100%; background:#000; overflow:hidden;
    overscroll-behavior-x:contain; font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;
    -webkit-user-select:none; user-select:none;
  }
  #viewer{
    display:flex; width:100%; height:100%;
    overflow-x:auto; overflow-y:hidden;
    scroll-snap-type:x mandatory;
    -webkit-overflow-scrolling:touch;
    scroll-behavior:smooth; position:relative;
  }
  #viewer.lock{ scroll-snap-type:none; }

  .page{
    min-width:100vw; height:100vh;
    display:flex; justify-content:center; align-items:center;
    scroll-snap-align:start; scroll-snap-stop:always;
    background:#000; position:relative; overflow:hidden;
  }

  .pz{
    width:100%; height:100%;
    position:relative;    /* önemli: mutlak konumlamada referans */
    touch-action: pan-x pan-y;
    contain: paint;
  }
  .img{
    position:absolute;    /* önemli: contain yerleşimi artık bizde */
    left:0; top:0;
    width:auto; height:auto;
    object-fit:contain;   /* görsel kalitesi için sorun değil, boyutu biz set edeceğiz */
    opacity:0; transition:opacity .18s ease;
    -webkit-user-drag:none; user-drag:none;
    will-change:transform, left, top, width, height;
    transform-origin: 0 0;       /* KRİTİK: hesapları basitleştirir */
    backface-visibility:hidden;
  }
  .img.ready{ opacity:1; }

  .skel{
    position:absolute; inset:0; background:
      radial-gradient(circle at 50% 45%, #1a1a1a 0 20%, #0a0a0a 60%);
    animation:pulse 1.2s ease-in-out infinite;
  }
  @keyframes pulse{50%{filter:brightness(1.15)}}

  #counter{
    position:fixed; left:50%; bottom:20px; transform:translateX(-50%);
    z-index:10; background:#111a; color:#fff;
    padding:10px 14px; border-radius:12px; font-size:28px; font-weight:700;
  }

  .navbtn{
    position:fixed; top:50%; transform:translateY(-50%);
    width:42px; height:64px; z-index:11; border:none; border-radius:12px;
    background:#111a; color:#ddd; font-size:22px;
    display:flex; align-items:center; justify-content:center;
  }
  .navbtn:active{filter:brightness(1.2)}
  #prev{ left:8px; display:none; }  /* ilk sayfada gizli */
  #next{ right:8px; }

  #err{
    position:absolute; inset:auto 12px 12px 12px; color:#bbb; background:#111a; padding:8px 10px; border-radius:8px; font-size:14px; display:none;
  }
</style>
</head>
<body>
  <div id="viewer"></div>
  <button id="prev" class="navbtn" aria-label="Önceki">‹</button>
  <button id="next" class="navbtn" aria-label="Sonraki">›</button>
  <div id="counter" hidden>— / —</div>
  <div id="err"></div>

<script>
(function(){
  const $ = sel => document.querySelector(sel);
  const viewer = $("#viewer");
  const counter = $("#counter");
  const btnPrev = $("#prev");
  const btnNext = $("#next");
  const errBox = $("#err");

  // -------- Parametreler --------
  const qp = new URLSearchParams(location.search);
  const rawM = qp.get("m") || qp.get("manifest") || qp.get("u") || qp.get("url");
  const rawX = qp.get("x") || qp.get("extra") || "";
  const manifestURL = rawM ? safeDecode(rawM) : "";
  const extraList = splitList(safeDecode(rawX));

  function safeDecode(s){ try{ return decodeURIComponent(s); }catch{ return s||""; } }
  function splitList(s){
    if(!s) return [];
    return s.split(/\r?\n|\|/g).join(",").split(",")
            .map(t=>t.trim()).filter(isLink);
  }
  function isLink(t){ return /^https?:\/\//i.test(t) || /^file:\/\/\/android_asset\//i.test(t); }
  function showErr(msg){ errBox.textContent = msg; errBox.style.display = "block"; console.warn(msg); }

  // -------- Manifest okuma --------
  async function readManifest(src){
    if (isLink(src)) {
      try{
        const resp = await fetch(src, {cache:"no-store", mode:"cors"});
        if(!resp.ok) throw new Error("HTTP " + resp.status);
        const text = await resp.text();
        return text.split(/\r?\n/).map(t=>t.trim()).filter(isLink);
      }catch(e){ showErr("Manifest okunamadı: " + e.message); return []; }
    } else {
      return src.split(/\r?\n/).map(t=>t.trim()).filter(isLink);
    }
  }
  function dedupe(arr){
    const out=[]; const seen=new Set();
    for(const u of arr){ const k=u.trim(); if(k && !seen.has(k)){ seen.add(k); out.push(k); } }
    return out;
  }

  // -------- DOM üretim --------
  function makePage(url, idx){
    const page = document.createElement("div");
    page.className = "page"; page.dataset.index = idx;
    const pz = document.createElement("div"); pz.className="pz";
    const sk = document.createElement("div"); sk.className="skel";
    const img = document.createElement("img"); img.className="img"; img.setAttribute("data-src", url);
    pz.appendChild(sk); pz.appendChild(img); page.appendChild(pz);
    attachZoomPan(pz, img);   // gerçek ankor zoom
    return {page, img, sk};
  }

  function loadImageAt(index){
    const page = viewer.querySelector(`.page[data-index="${index}"]`);
    if(!page) return;
    const img = page.querySelector(".img");
    const sk  = page.querySelector(".skel");
    if(img.dataset.loaded) return;

    const src = img.getAttribute("data-src");
    img.onload = ()=>{
      // Görsel metriklerini hazırla
      initImageMetrics(img);
      sk && sk.remove();
      img.classList.add("ready");
    };
    img.onerror = ()=>{ sk && sk.remove(); img.alt="Görüntü yüklenemedi"; img.classList.add("ready"); };
    img.src = src;
    img.dataset.loaded = "1";
  }

  function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }

  // -------- Sayaç / gezinme --------
  let total = 0;
  function currentIndex(){
    const w = viewer.clientWidth || 1;
    return clamp(Math.round(viewer.scrollLeft / w), 0, Math.max(0, total-1));
  }
  function updateVisible(){
    const idx = currentIndex();
    loadImageAt(idx); loadImageAt(idx-1); loadImageAt(idx+1);
    counter.hidden = false;
    counter.textContent = `${idx+1} / ${total}`;
    btnPrev.style.display = (idx === 0) ? "none" : "flex";
    btnNext.style.display = (idx === total-1) ? "none" : "flex";
  }

  let snapTimer;
  function onScroll(){
    clearTimeout(snapTimer);
    snapTimer = setTimeout(()=>{
      const w = viewer.clientWidth;
      const target = Math.round(viewer.scrollLeft / w) * w;
      viewer.scrollTo({left: target, behavior:"smooth"});
      updateVisible();
    }, 80);
  }

  function go(delta){
    const w = viewer.clientWidth;
    const idx = currentIndex();
    const targetIdx = clamp(idx + delta, 0, total - 1);
    viewer.scrollTo({left: targetIdx * w, behavior:"smooth"});
    loadImageAt(targetIdx); loadImageAt(targetIdx-1); loadImageAt(targetIdx+1);
    counter.textContent = `${targetIdx+1} / ${total}`;
    btnPrev.style.display = (targetIdx === 0) ? "none" : "flex";
    btnNext.style.display = (targetIdx === total-1) ? "none" : "flex";
  }
  btnPrev.addEventListener("click", ()=>go(-1));
  btnNext.addEventListener("click", ()=>go(1));

  // =======================
  //   GÖRSEL METRİKLERİ
  // =======================
  function initImageMetrics(img){
    const container = img.parentElement; // .pz
    const cw = container.clientWidth;
    const ch = container.clientHeight;

    const nw = img.naturalWidth || 1;
    const nh = img.naturalHeight || 1;

    const fit = Math.min(cw / nw, ch / nh);       // contain ölçeği
    const vw = nw * fit;                           // görüntülenen genişlik
    const vh = nh * fit;                           // görüntülenen yükseklik
    const ox = (cw - vw) / 2;                      // soldan boşluk
    const oy = (ch - vh) / 2;                      // yukarıdan boşluk

    // img’i mutlak piksel boyutunda ve ofsette yerleştir
    img.style.left   = `${ox}px`;
    img.style.top    = `${oy}px`;
    img.style.width  = `${vw}px`;
    img.style.height = `${vh}px`;
    img.style.transform = `translate(0px, 0px) scale(1)`;

    // state’i img üzerinde sakla
    img._zoomState = {
      fit, ox, oy, nw, nh,
      scale: 1,   // ek zoom (fit’in üstüne)
      tx: 0, ty: 0,
      dragging:false, lx:0, ly:0,
      pinch:false, startDist:0, startScale:1
    };

    // mevcut handler’ı varsa tekrar bağlama
    if (!img._zoomBound) {
      attachTrueAnchorZoom(container, img);
      img._zoomBound = true;
    }
  }

  // =======================
  //   TRUE ANCHOR ZOOM
  // =======================
  function attachTrueAnchorZoom(container, img){
    const viewerPerfLock = (on)=>{
      if(on){
        viewer.classList.add("lock");
        viewer.style.webkitOverflowScrolling = "auto";
        viewer.style.scrollBehavior = "auto";
        container.style.touchAction = "none";
      }else{
        viewer.style.webkitOverflowScrolling = "touch";
        viewer.style.scrollBehavior = "smooth";
        container.style.touchAction = "pan-x pan-y";
        const st = img._zoomState;
        if (st && st.scale<=1.0001) viewer.classList.remove("lock");
      }
    };

    function render(){
      const st = img._zoomState;
      img.style.transform = `translate(${st.tx}px, ${st.ty}px) scale(${st.scale})`;
    }

    function clampPan(){
      const st = img._zoomState;
      // Görüntü tabanı: width = vw, height = vh; transform-origin:0 0
      const vw = parseFloat(img.style.width)  || 0;
      const vh = parseFloat(img.style.height) || 0;
      const cw = container.clientWidth;
      const ch = container.clientHeight;

      // ekstra alan (ekran yarıçapı mantığı değil, gerçek sınırlama)
      const maxX = Math.max(0, (vw*st.scale - vw)/2 + vw*st.scale - cw + st.ox ?? 0);
      const maxY = Math.max(0, (vh*st.scale - vh)/2 + vh*st.scale - ch + st.oy ?? 0);

      // daha pratik ve stabil sınır: görüntünün kenarı ekran dışına sınırsız gitmesin
      const exX = (vw*st.scale - cw);
      const exY = (vh*st.scale - ch);
      const minTx = -Math.max(0, exX) - st.ox;
      const maxTx = Math.max(0, exX) + st.ox;
      const minTy = -Math.max(0, exY) - st.oy;
      const maxTy = Math.max(0, exY) + st.oy;

      st.tx = clamp(st.tx, minTx, maxTx);
      st.ty = clamp(st.ty, minTy, maxTy);
    }

    function zoomAt(clientX, clientY, nextScale){
      const st = img._zoomState;
      const cw = container.clientWidth;
      const ch = container.clientHeight;

      nextScale = clamp(nextScale, 1, 4);

      // dünya noktası (görsel pikseli) — transform-origin:0 0 olduğu için kolay:
      // world = (p - (ox,oy) - (tx,ty)) / (fit*scale)
      const denomPrev = st.fit * st.scale;
      const worldX = (clientX - container.getBoundingClientRect().left - st.ox - st.tx) / denomPrev;
      const worldY = (clientY - container.getBoundingClientRect().top  - st.oy - st.ty) / denomPrev;

      // yeni ölçekte aynı noktayı parmak altında tut
      const denomNext = st.fit * nextScale;
      const targetDisplayX = clientX - container.getBoundingClientRect().left;
      const targetDisplayY = clientY - container.getBoundingClientRect().top;

      const newTx = targetDisplayX - st.ox - worldX * denomNext;
      const newTy = targetDisplayY - st.oy - worldY * denomNext;

      st.scale = nextScale;
      st.tx = newTx;
      st.ty = newTy;

      clampPan();
      render();
    }

    // ---- MOUSE WHEEL (opsiyonel) ----
    const WHEEL_SENS = 0.0012, STEP_CAP = 0.16;
    container.addEventListener("wheel", (e)=>{
      e.preventDefault();
      const st = img._zoomState;
      const raw = Math.exp(-e.deltaY * WHEEL_SENS);
      const factor = clamp(raw, 1-STEP_CAP, 1+STEP_CAP);
      zoomAt(e.clientX, e.clientY, st.scale * factor);
      viewerPerfLock(st.scale>1.0001);
      clearTimeout(container._wheelEndT);
      container._wheelEndT = setTimeout(()=>{ if (st.scale<=1.0001) viewerPerfLock(false); }, 120);
    }, {passive:false});

    // ---- POINTER / TOUCH birlikte ----
    let p1=null, p2=null, pinchActive=false, pinchStartDist=0, pinchStartScale=1;

    container.addEventListener("pointerdown", (e)=>{
      container.setPointerCapture(e.pointerId);
      const st = img._zoomState;
      if (!p1) p1={id:e.pointerId,x:e.clientX,y:e.clientY};
      else if (!p2 && e.pointerId!==p1.id) p2={id:e.pointerId,x:e.clientX,y:e.clientY};

      if (p1 && !p2 && st.scale>1){
        st.dragging=true; st.lx=e.clientX; st.ly=e.clientY;
        viewerPerfLock(true);
      }
      if (p1 && p2){
        pinchActive=false;
        pinchStartDist = Math.hypot(p2.x-p1.x, p2.y-p1.y);
        pinchStartScale = st.scale;
        viewerPerfLock(true);
      }
    });

    container.addEventListener("pointermove", (e)=>{
      if (p1 && e.pointerId===p1.id){ p1.x=e.clientX; p1.y=e.clientY; }
      if (p2 && e.pointerId===p2.id){ p2.x=e.clientX; p2.y=e.clientY; }

      const st = img._zoomState;

      // PINCH
      if (p1 && p2){
        e.preventDefault();
        const dist = Math.hypot(p2.x-p1.x, p2.y-p1.y);
        if (!pinchActive){
          if (Math.abs(dist - pinchStartDist) < 10) return;
          pinchActive = true;
          pinchStartDist = dist;
          pinchStartScale = st.scale;
        }
        const centroidX = (p1.x + p2.x)/2;
        const centroidY = (p1.y + p2.y)/2;
        const next = clamp(pinchStartScale * (dist / (pinchStartDist || 1)), 1, 4);
        zoomAt(centroidX, centroidY, next);
        return;
      }

      // PAN — yalnızca zoom>1 iken
      if (st.dragging && st.scale>1){
        e.preventDefault();
        const dx = e.clientX - st.lx;
        const dy = e.clientY - st.ly;
        st.lx = e.clientX; st.ly = e.clientY;
        st.tx += dx; st.ty += dy;
        clampPan(); render();
      }
    }, {passive:false});

    function endPointer(e){
      const st = img._zoomState;
      if (p1 && e.pointerId===p1.id) p1=null;
      if (p2 && e.pointerId===p2.id) p2=null;
      if (!(p1&&p2)) pinchActive=false;

      if (!p1 && !p2){
        st.dragging=false;
        if (st.scale<=1.0001){
          st.scale=1; st.tx=0; st.ty=0; render(); viewerPerfLock(false);
        }else{
          viewerPerfLock(true);
        }
      }
    }
    container.addEventListener("pointerup", endPointer);
    container.addEventListener("pointercancel", endPointer);
    container.addEventListener("pointerleave", endPointer);

    // TOUCH fallback (bazı cihazlarda)
    container.addEventListener("touchstart", (e)=>{ if(e.touches.length>=2) viewerPerfLock(true); }, {passive:true});
    container.addEventListener("touchmove", (e)=>{
      const st = img._zoomState;
      if (e.touches.length===2){
        e.preventDefault();
        const t0=e.touches[0], t1=e.touches[1];
        const dist = Math.hypot(t1.clientX-t0.clientX, t1.clientY-t0.clientY);
        if (!pinchActive){ pinchActive=true; pinchStartDist=dist; pinchStartScale=st.scale; }
        const cx=(t0.clientX+t1.clientX)/2, cy=(t0.clientY+t1.clientY)/2;
        const next = clamp(pinchStartScale * (dist / (pinchStartDist || 1)), 1, 4);
        zoomAt(cx, cy, next);
        return;
      }
      if (e.touches.length===1 && st.scale>1){
        e.preventDefault();
        const x=e.touches[0].clientX, y=e.touches[0].clientY;
        if (!st.dragging){ st.dragging=true; st.lx=x; st.ly=y; return; }
        const dx=x-st.lx, dy=y-st.ly; st.lx=x; st.ly=y;
        st.tx += dx; st.ty += dy;
        clampPan(); render();
      }
    }, {passive:false});
    container.addEventListener("touchend", (e)=>{
      const st = img._zoomState;
      if (e.touches.length===0){
        st.dragging=false; pinchActive=false;
        if (st.scale<=1.0001){
          st.scale=1; st.tx=0; st.ty=0; render(); viewerPerfLock(false);
        }else{
          viewerPerfLock(true);
        }
      }
    }, {passive:true});

    // yeniden boyutlandığında contain düzenini güncelle
    window.addEventListener("resize", ()=>{
      // mevcut dünya merkezini mümkün olduğunca koru
      const st = img._zoomState;
      const rect = container.getBoundingClientRect();
      const centerX = rect.left + rect.width/2;
      const centerY = rect.top  + rect.height/2;
      const prevScale = st.scale;
      initImageMetrics(img); // fit, ox/oy ve boyutlar reset
      const st2 = img._zoomState;
      st2.scale = prevScale;
      zoomAt(centerX, centerY, st2.scale);
    });
  }

  // -------- Başlat --------
  (async function init(){
    let list = [];

    if (manifestURL) {
      list = await readManifest(manifestURL);
    } else {
      const wvs = (window.AppInventor && typeof window.AppInventor.getWebViewString==="function")
                    ? String(window.AppInventor.getWebViewString()||"")
                    : "";
      if (wvs){
        try{
          const d = JSON.parse(wvs);
          if (d && d.manifest) list = await readManifest(String(d.manifest));
          if (Array.isArray(d.extra)) list = (d.extra.filter(isLink)).concat(list);
        }catch{
          if (isLink(wvs)) list = await readManifest(wvs);
          else list = wvs.split(/\r?\n/).map(t=>t.trim()).filter(isLink);
        }
      }
    }

    list = dedupe(extraList.concat(list));

    if (!list.length){
      showErr("Gösterilecek resim bulunamadı. (Parametre: m / manifest / u / url veya WebViewString ile gönderin.)");
      viewer.innerHTML = '<div class="page" data-index="0"><div class="pz"><div class="skel"></div></div></div>';
      total = 1;
      updateVisible();
      return;
    }

    const frag = document.createDocumentFragment();
    list.forEach((url, i)=>{
      const {page} = makePage(url, i);
      frag.appendChild(page);
    });
    viewer.appendChild(frag);
    total = list.length;

    updateVisible();
    viewer.addEventListener("scroll", onScroll);
    window.addEventListener("resize", updateVisible);
  })();
})();
</script>
</body>
</html>
