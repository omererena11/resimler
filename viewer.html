<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=5, user-scalable=no"/>
<meta name="referrer" content="no-referrer"/>
<title>Viewer (Zoom + Pan + Counter)</title>
<style>
  html, body{
    margin:0; padding:0; height:100%; background:#000; overflow:hidden;
    overscroll-behavior-x:contain; font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;
    -webkit-user-select:none; user-select:none;
  }
  #viewer{
    display:flex; width:100%; height:100%;
    overflow-x:auto; overflow-y:hidden;
    scroll-snap-type:x mandatory;
    -webkit-overflow-scrolling:touch;
    scroll-behavior:smooth; position:relative;
    will-change:scroll-position; /* NEW: daha stabil kaydırma */
  }
  #viewer.lock{ scroll-snap-type:none; }

  .page{
    min-width:100vw; height:100vh;
    display:flex; justify-content:center; align-items:center;
    scroll-snap-align:start; scroll-snap-stop:always;
    background:#000; position:relative; overflow:hidden;
  }

  .pz{
    width:100%; height:100%;
    display:flex; justify-content:center; align-items:center;
    position:relative;
    touch-action: pan-x pan-y;
    cursor: default;
    contain: paint;               /* NEW: çizimi izole et, flicker azalır */
  }
  .img{
    max-width:100%; max-height:100%;
    object-fit:contain; background:#000;
    opacity:0; transition:opacity .18s ease;
    -webkit-user-drag:none; user-drag:none; pointer-events:auto;
    will-change:transform;
    transform-origin:center center;
    backface-visibility:hidden;   /* NEW */
    transform: translateZ(0);     /* NEW: GPU layer */
  }
  .img.ready{ opacity:1; }

  .skel{
    position:absolute; inset:0; background:
      radial-gradient(circle at 50% 45%, #1a1a1a 0 20%, #0a0a0a 60%);
    animation:pulse 1.2s ease-in-out infinite;
  }
  @keyframes pulse{50%{filter:brightness(1.15)}}

  /* Sayaç */
  #counter{
    position:fixed;
    left:50%;
    bottom:20px;
    transform:translateX(-50%);
    z-index:10;
    background:#111a; color:#fff;
    padding:10px 14px; border-radius:12px;
    font-size:28px; font-weight:700; letter-spacing:.05em;
    backdrop-filter:blur(3px);
  }

  .navbtn{
    position:fixed; top:50%; transform:translateY(-50%);
    width:42px; height:64px; z-index:11; border:none; border-radius:12px;
    background:#111a; color:#ddd; font-size:22px;
    display:flex; align-items:center; justify-content:center;
    backdrop-filter:blur(3px);
  }
  .navbtn:active{filter:brightness(1.2)}
  #prev{ left:8px; }  #next{ right:8px; }

  #err{
    position:absolute; inset:auto 12px 12px 12px; color:#bbb; background:#111a; padding:8px 10px; border-radius:8px; font-size:14px; display:none;
  }
</style>
</head>
<body>
  <div id="viewer"></div>
  <button id="prev" class="navbtn" aria-label="Önceki">‹</button>
  <button id="next" class="navbtn" aria-label="Sonraki">›</button>
  <div id="counter" hidden>— / —</div>
  <div id="err"></div>

<script>
(function(){
  const $ = sel => document.querySelector(sel);
  const viewer = $("#viewer");
  const counter = $("#counter");
  const btnPrev = $("#prev");
  const btnNext = $("#next");
  const errBox = $("#err");

  const qp = new URLSearchParams(location.search);
  const rawM = qp.get("m") || qp.get("manifest") || qp.get("u") || qp.get("url");
  const rawX = qp.get("x") || qp.get("extra") || "";
  const manifestURL = rawM ? safeDecode(rawM) : "";
  const extraList = splitList(safeDecode(rawX));

  function safeDecode(s){ try{ return decodeURIComponent(s); }catch{ return s||""; } }
  function splitList(s){
    if(!s) return [];
    return s.split(/\r?\n|\|/g).join(",").split(",")
            .map(t=>t.trim()).filter(isLink);
  }
  function isLink(t){ return /^https?:\/\//i.test(t) || /^file:\/\/\/android_asset\//i.test(t); }
  function showErr(msg){ errBox.textContent = msg; errBox.style.display = "block"; console.warn(msg); }

  async function readManifest(src){
    if (isLink(src)) {
      try{
        const resp = await fetch(src, {cache:"no-store", mode:"cors"});
        if(!resp.ok) throw new Error("HTTP " + resp.status);
        const text = await resp.text();
        return text.split(/\r?\n/).map(t=>t.trim()).filter(isLink);
      }catch(e){ showErr("Manifest okunamadı: " + e.message); return []; }
    } else {
      return src.split(/\r?\n/).map(t=>t.trim()).filter(isLink);
    }
  }
  function dedupe(arr){
    const out=[]; const seen=new Set();
    for(const u of arr){ const k=u.trim(); if(k && !seen.has(k)){ seen.add(k); out.push(k); } }
    return out;
  }

  function makePage(url, idx){
    const page = document.createElement("div");
    page.className = "page"; page.dataset.index = idx;
    const pz = document.createElement("div"); pz.className="pz";
    const sk = document.createElement("div"); sk.className="skel";
    const img = document.createElement("img"); img.className="img"; img.setAttribute("data-src", url);
    pz.appendChild(sk); pz.appendChild(img); page.appendChild(pz);
    attachZoomPan(pz, img);   // zoom/pan bağla
    return {page, img, sk};
  }

  function loadImageAt(index){
    const page = viewer.querySelector(`.page[data-index="${index}"]`);
    if(!page) return;
    const img = page.querySelector(".img");
    const sk  = page.querySelector(".skel");
    if(img.dataset.loaded) return;
    const src = img.getAttribute("data-src");
    img.onload = ()=>{ sk && sk.remove(); img.classList.add("ready"); };
    img.onerror = ()=>{ sk && sk.remove(); img.alt="Görüntü yüklenemedi"; img.classList.add("ready"); };
    img.src = src;
    img.dataset.loaded = "1";
  }

  function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }

  let total = 0;
  function currentIndex(){
    const w = viewer.clientWidth || 1;
    return clamp(Math.round(viewer.scrollLeft / w), 0, Math.max(0, total-1));
  }
  function updateVisible(){
    const idx = currentIndex();
    loadImageAt(idx); loadImageAt(idx-1); loadImageAt(idx+1);
    counter.hidden = false;
    counter.textContent = `${idx+1} / ${total}`;
  }

  let snapTimer;
  function onScroll(){
    clearTimeout(snapTimer);
    snapTimer = setTimeout(()=>{
      const w = viewer.clientWidth;
      const target = Math.round(viewer.scrollLeft / w) * w;
      viewer.scrollTo({left: target, behavior:"smooth"});
      updateVisible();
    }, 80);
  }

  function go(delta){
    const w = viewer.clientWidth;
    const idx = currentIndex();
    const targetIdx = clamp(idx + delta, 0, total - 1);
    viewer.scrollTo({left: targetIdx * w, behavior:"smooth"});
    loadImageAt(targetIdx); loadImageAt(targetIdx-1); loadImageAt(targetIdx+1);
    counter.textContent = `${targetIdx+1} / ${total}`;
  }
  btnPrev.addEventListener("click", ()=>go(-1));
  btnNext.addEventListener("click", ()=>go(1));

  // =======================
  //   ZOOM + PAN (SMOOTH)
  // =======================
  function attachZoomPan(container, img){
    const state = {
      scale: 1, min: 1, max: 4,
      tx: 0, ty: 0,
      dragging: false, lx: 0, ly: 0,
      pointers: new Map(),
      zoomMode: false,        // NEW: snap/touchAction geçişini kontrol eder
      rafPending: false,      // NEW: transform’u RAF ile uygula
      targetTransform: ""     // NEW
    };

    // Sabitler
    const WHEEL_SENS_IN  = 0.0009;
    const WHEEL_SENS_OUT = 0.0009;
    const STEP_CAP_IN    = 0.08;
    const STEP_CAP_OUT   = 0.08;
    const PINCH_DIV_IN   = 480;
    const PINCH_DIV_OUT  = 480;
    const WHEEL_DEAD     = 3;
    const PINCH_START_THRESHOLD = 16;
    const USE_CTRL_WHEEL = false;

    // NEW: Zoom modunu sadece gerektiğinde değiştir
    function setZoomMode(on){
      if (on === state.zoomMode) return;
      state.zoomMode = on;
      if (on){
        viewer.classList.add("lock");
        container.style.touchAction = "none";
        container.style.cursor = "grab";
      }else{
        viewer.classList.remove("lock");
        container.style.touchAction = "pan-x pan-y";
        container.style.cursor = "default";
      }
    }

    // NEW: transform’u tek frame’de uygula
    function scheduleTransform(){
      if (state.rafPending) return;
      state.rafPending = true;
      requestAnimationFrame(()=>{
        img.style.transform = state.targetTransform;
        state.rafPending = false;
      });
    }

    function composeTransform(){
      return `translate(${state.tx}px, ${state.ty}px) scale(${state.scale})`;
    }

    function clampTranslate(){
      const rect = container.getBoundingClientRect();
      const vw = rect.width, vh = rect.height;
      const extraX = (state.scale - 1) * (vw/2);
      const extraY = (state.scale - 1) * (vh/2);
      state.tx = clamp(state.tx, -extraX, extraX);
      state.ty = clamp(state.ty, -extraY, extraY);
      state.targetTransform = composeTransform();
      scheduleTransform();
    }

    // Zoom seviyesine göre mod geçişi — her karede değil, yalnızca eşik geçişinde
    function updateZoomModeByScale(){
      setZoomMode(state.scale > 1.0001);
    }

    // Mouse wheel zoom (yumuşak)
    let wheelEndT = null;
    function commitWheelEndSoon(){
      clearTimeout(wheelEndT);
      wheelEndT = setTimeout(()=>{
        // 1x yakınsa tam 1x’e oturt, pan’ı sıfırla (blink’i engeller)
        if (state.scale <= 1.0001){
          state.scale = 1; state.tx = 0; state.ty = 0;
          updateZoomModeByScale();
          state.targetTransform = composeTransform();
          scheduleTransform();
        }
      }, 120);
    }

    container.addEventListener("wheel", (e)=>{
      e.preventDefault();
      if (USE_CTRL_WHEEL && !e.ctrlKey) return;
      if (Math.abs(e.deltaY) < WHEEL_DEAD) return;

      const rect = container.getBoundingClientRect();
      const cx = e.clientX - rect.left - rect.width/2 + state.tx;
      const cy = e.clientY - rect.top  - rect.height/2 + state.ty;

      const prev = state.scale;
      const isOut = e.deltaY > 0;
      const sens  = isOut ? WHEEL_SENS_OUT : WHEEL_SENS_IN;
      const cap   = isOut ? STEP_CAP_OUT   : STEP_CAP_IN;
      const raw   = Math.exp(-e.deltaY * sens);
      const factor= Math.min(Math.max(raw, 1-cap), 1+cap);
      const next  = clamp(prev * factor, state.min, state.max);
      if (next === prev) return;

      // Google Maps benzeri: odak noktasını koru
      state.tx = cx - (cx - state.tx) * (next/prev);
      state.ty = cy - (cy - state.ty) * (next/prev);
      state.scale = next;

      updateZoomModeByScale();
      clampTranslate();
      commitWheelEndSoon();
    }, {passive:false});

    // Pointer (pinch + pan)
    container.addEventListener("pointerdown", (e)=>{
      container.setPointerCapture(e.pointerId);
      state.pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
      if(state.pointers.size===1 && state.scale>1){
        state.dragging = true; state.lx = e.clientX; state.ly = e.clientY;
        container.style.cursor = "grabbing";
      }
    });

    container.addEventListener("pointermove", (e)=>{
      if(state.pointers.has(e.pointerId)){
        state.pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
      }

      // Pinch (2 parmak)
      if(state.pointers.size===2){
        const [a,b] = Array.from(state.pointers.values());
        const dx = b.x - a.x, dy = b.y - a.y;
        const dist = Math.hypot(dx,dy);

        if(state._pinchBaseDist == null){
          state._pinchBaseDist = dist;
          state._pinchActive   = false;
          state._lastDist      = dist;
          return;
        }
        const deltaAbs = Math.abs(dist - state._pinchBaseDist);
        if(!state._pinchActive){
          if(deltaAbs < PINCH_START_THRESHOLD) return;
          state._pinchActive = true;
          state._lastDist    = dist;
        }

        const delta = dist - (state._lastDist ?? dist);
        state._lastDist = dist;

        const rect = container.getBoundingClientRect();
        const cx = (a.x + b.x)/2 - rect.left - rect.width/2 + state.tx;
        const cy = (a.y + b.y)/2 - rect.top  - rect.height/2 + state.ty;

        const prev = state.scale;
        const isOut = delta < 0;
        const divisor = isOut ? PINCH_DIV_OUT : PINCH_DIV_IN;
        const cap     = isOut ? STEP_CAP_OUT  : STEP_CAP_IN;
        const rawFactor = 1 + (delta / divisor);
        const factor    = Math.min(Math.max(rawFactor, 1-cap), 1+cap);
        const next      = clamp(prev * factor, state.min, state.max);
        if (next === prev) return;

        state.tx = cx - (cx - state.tx) * (next/prev);
        state.ty = cy - (cy - state.ty) * (next/prev);
        state.scale = next;

        updateZoomModeByScale();
        clampTranslate();
      }

      // Pan — sadece zoom>1 iken
      if(state.dragging && state.scale>1){
        const dx = e.clientX - state.lx;
        const dy = e.clientY - state.ly;
        state.lx = e.clientX; state.ly = e.clientY;
        state.tx += dx; state.ty += dy;
        clampTranslate();
      }
    }, {passive:false});

    function endPointer(e){
      if(state.pointers.has(e.pointerId)) state.pointers.delete(e.pointerId);
      if(state.pointers.size<2){
        state._pinchBaseDist = null;
        state._pinchActive   = false;
        state._lastDist      = null;
      }
      if(state.dragging){
        state.dragging = false;
        container.style.cursor = (state.scale>1) ? "grab" : "default";
        clampTranslate();
      }
      // NEW: Jest bittiğinde 1x yakınsa net 1x’e otur
      if (state.pointers.size === 0){
        if (state.scale <= 1.0001){
          state.scale = 1; state.tx = 0; state.ty = 0;
          updateZoomModeByScale();
          state.targetTransform = composeTransform();
          scheduleTransform();
        }
      }
    }
    container.addEventListener("pointerup", endPointer);
    container.addEventListener("pointercancel", endPointer);
    container.addEventListener("pointerleave", endPointer);
  }

  // -------- Başlat --------
  (async function init(){
    let list = [];

    if (manifestURL) {
      list = await readManifest(manifestURL);
    } else {
      const wvs = (window.AppInventor && typeof window.AppInventor.getWebViewString==="function")
                    ? String(window.AppInventor.getWebViewString()||"")
                    : "";
      if (wvs){
        try{
          const d = JSON.parse(wvs);
          if (d && d.manifest) list = await readManifest(String(d.manifest));
          if (Array.isArray(d.extra)) list = (d.extra.filter(isLink)).concat(list);
        }catch{
          if (isLink(wvs)) list = await readManifest(wvs);
          else list = wvs.split(/\r?\n/).map(t=>t.trim()).filter(isLink);
        }
      }
    }

    list = dedupe(extraList.concat(list));

    if (!list.length){
      showErr("Gösterilecek resim bulunamadı. (Parametre: m / manifest / u / url veya WebViewString ile gönderin.)");
      viewer.innerHTML = '<div class="page" data-index="0"><div class="pz"><div class="skel"></div></div></div>';
      total = 1;
      updateVisible();
      return;
    }

    const frag = document.createDocumentFragment();
    list.forEach((url, i)=>{
      const {page} = makePage(url, i);
      frag.appendChild(page);
    });
    viewer.appendChild(frag);
    total = list.length;

    updateVisible();
    viewer.addEventListener("scroll", onScroll);
    window.addEventListener("resize", updateVisible);
  })();
})();
</script>
</body>
</html>
