<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<meta name="referrer" content="no-referrer"/>
<title>Viewer • Carousel + Pinch Zoom v3</title>
<style>
  html,body{margin:0;height:100%;background:#000;color:#ddd;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;-webkit-user-select:none;user-select:none;overflow:hidden}
  .app{position:relative;height:100%;width:100%}

  /* görünür alan */
  .frame{position:absolute;inset:0;overflow:hidden;background:#000}

  /* scroll yok, translateX ile sayfa değiştiriyoruz */
  .track{height:100%;display:flex;will-change:transform;transform:translateX(0);transition:transform .28s ease}
  .dragging .track{transition:none}
  .slide{min-width:100vw;height:100vh;display:flex;justify-content:center;align-items:center;background:#000;position:relative;overflow:hidden;touch-action:none}

  .ph{position:absolute;inset:0;background:radial-gradient(circle at 50% 45%, #1a1a1a 0 20%, #0a0a0a 60%);animation:pulse 1.2s ease-in-out infinite}
  @keyframes pulse{50%{filter:brightness(1.15)}}

  .img{max-width:100%;max-height:100%;object-fit:contain;background:#000;opacity:0;transition:opacity .2s ease;-webkit-user-drag:none;user-drag:none;will-change:transform;transform-origin:center center}
  .img.ready{opacity:1}

  .hud{position:absolute;left:12px;bottom:12px;background:#111a;border-radius:10px;padding:6px 10px;font-size:14px;backdrop-filter:blur(3px);z-index:5}
  .btn{position:absolute;top:50%;transform:translateY(-50%);width:42px;height:64px;border:none;border-radius:12px;background:#111a;color:#ddd;font-size:22px;display:flex;align-items:center;justify-content:center;z-index:5}
  .btn:active{filter:brightness(1.2)}
  .prev{left:8px}.next{right:8px}
</style>
</head>
<body>
<div class="app" id="app">
  <div class="frame" id="frame">
    <div class="track" id="track"></div>
  </div>
  <button class="btn prev" id="btnPrev" aria-label="Önceki">‹</button>
  <button class="btn next" id="btnNext" aria-label="Sonraki">›</button>
  <div class="hud" id="counter">— / —</div>
</div>

<script>
(function(){
  const $ = s => document.querySelector(s);
  const app   = $("#app");
  const frame = $("#frame");
  const track = $("#track");
  const counter = $("#counter");
  const btnPrev = $("#btnPrev");
  const btnNext = $("#btnNext");

  // -------- manifest --------
  const qp = new URLSearchParams(location.search);
  const rawM = qp.get("m") || qp.get("manifest") || qp.get("u") || qp.get("url");
  const manifestURL = rawM ? safeDecode(rawM) : "";
  function safeDecode(s){ try{ return decodeURIComponent(s);}catch{ return s||"";} }
  function isLink(t){ return /^https?:\/\//i.test(t) || /^file:\/\/\/android_asset\//i.test(t); }
  async function readManifest(src){
    if(isLink(src)){
      const resp = await fetch(src,{cache:"no-store",mode:"cors"});
      if(!resp.ok) throw new Error("HTTP "+resp.status);
      return (await resp.text()).split(/\r?\n/).map(t=>t.trim()).filter(isLink);
    }else{
      return (src||"").split(/\r?\n/).map(t=>t.trim()).filter(isLink);
    }
  }

  // -------- carousel state --------
  let urls = [];
  let idx = 0;
  let W = window.innerWidth;
  let dragging = false, startX=0, currX=0, baseOffset=0;

  const clamp = (n,a,b)=>Math.max(a,Math.min(b,n));
  const setCounter = ()=> counter.textContent = `${(idx+1)} / ${urls.length}`;
  const setTransform = (x)=> track.style.transform = `translateX(${x}px)`;
  const targetOf = (i)=> -i * W;

  function buildSlides(list){
    const frag = document.createDocumentFragment();
    list.forEach((u,i)=>{
      const s = document.createElement("div");
      s.className = "slide";
      const ph = document.createElement("div"); ph.className="ph";
      const img = document.createElement("img"); img.className="img"; img.dataset.src = u;
      img.onload = ()=>{ ph.remove(); img.classList.add("ready"); };
      img.onerror = ()=>{ ph.remove(); img.alt="Görüntü yüklenemedi"; img.classList.add("ready"); };
      s.appendChild(ph); s.appendChild(img);
      attachPinchZoom(s, img, i); // index'i parametreyle veriyoruz → doğru state
      frag.appendChild(s);
    });
    track.innerHTML = ""; track.appendChild(frag);
  }

  // Lazy: aktif ve komşular
  function lazyAt(i){
    const slide = track.children[i]; if(!slide) return;
    const img = slide.querySelector(".img");
    if(!img || img.dataset.loaded) return;
    img.src = img.dataset.src; img.dataset.loaded = "1";
  }
  function lazyAround(i){ lazyAt(i); lazyAt(i-1); lazyAt(i+1); }

  function goTo(i, animate=true){
    idx = clamp(i, 0, urls.length-1);
    track.style.transition = animate ? "" : "none";
    setTransform(targetOf(idx));
    setCounter();
    lazyAround(idx);
  }

  // -------- swipe (scroll yok) sadece frame'de --------
  function currentZoom(){ return (zoomStates.get(idx)?.scale || 1); }

  frame.addEventListener("pointerdown", e=>{
    // yalnızca bir parmak ve zoom=1 iken sayfa sürükleme başlasın
    if(!e.isPrimary || currentZoom()>1) return;
    frame.setPointerCapture(e.pointerId);
    dragging = true; app.classList.add("dragging");
    startX = currX = e.clientX;
    baseOffset = targetOf(idx);
  });
  frame.addEventListener("pointermove", e=>{
    if(!dragging) return;
    currX = e.clientX;
    const delta = currX - startX;
    const atStart = (idx===0 && delta>0);
    const atEnd   = (idx===urls.length-1 && delta<0);
    const damp = (atStart || atEnd) ? 0.35 : 1;
    setTransform(baseOffset + delta * damp);
  });
  function endSwipe(){
    if(!dragging) return;
    dragging = false; app.classList.remove("dragging");
    const delta = currX - startX;
    const abs = Math.abs(delta);
    const threshold = Math.max(60, W*0.15);
    if(abs >= threshold){
      goTo(idx + (delta<0 ? 1 : -1));
    }else{
      goTo(idx); // geri otur
    }
  }
  frame.addEventListener("pointerup", endSwipe);
  frame.addEventListener("pointercancel", endSwipe);
  frame.addEventListener("pointerleave", endSwipe);

  // Butonlar
  btnPrev.addEventListener("click", ()=> goTo(idx-1));
  btnNext.addEventListener("click", ()=> goTo(idx+1));

  // Resize
  window.addEventListener("resize", ()=>{ W = window.innerWidth; goTo(idx,false); });

  // -------- Pinch Zoom --------
  const zoomStates = new Map(); // index -> {scale, tx, ty, ...}
  function getZoomState(i){
    if(!zoomStates.has(i)){
      zoomStates.set(i, {scale:1, tx:0, ty:0, pointers:new Map(), pinching:false, baseDist:0, lastCx:0, lastCy:0});
    }
    return zoomStates.get(i);
  }

  // hassasiyet/limitler
  const STEP_CAP_IN  = 0.12;   // tek olayda max +%12
  const STEP_CAP_OUT = 0.08;   // tek olayda max -%8 (zoom-out daha yumuşak)
  const PINCH_DIV_IN   = 340;  // açılırken
  const PINCH_DIV_OUT  = 460;  // kapanırken daha yumuşak
  const PINCH_START_THRESHOLD = 16; // pinch başlamadan önce gerekli min fark (px)

  function attachPinchZoom(container, img, index){
    function apply(z){
      img.style.transform = `translate(${z.tx}px, ${z.ty}px) scale(${z.scale})`;
    }
    function clampTranslate(z){
      const rect = container.getBoundingClientRect();
      const vw = rect.width, vh = rect.height;
      const extraX = (z.scale - 1) * (vw/2);
      const extraY = (z.scale - 1) * (vh/2);
      z.tx = clamp(z.tx, -extraX, extraX);
      z.ty = clamp(z.ty, -extraY, extraY);
      apply(z);
    }

    container.addEventListener("pointerdown", (e)=>{
      // Pinch/zoom olayları slide içinde; swipe ile çakışmaması için,
      // ikinci parmak geldiyse swipe başlamasın:
      const z = getZoomState(index);
      z.pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
      if(z.pointers.size===2){
        const [a,b] = Array.from(z.pointers.values());
        z.baseDist = Math.hypot(b.x - a.x, b.y - a.y);
        z.pinching = false; // eşik aşılana dek zoom yok
        // frame'deki swipe'ın başlamasını engelle
        e.stopPropagation();
      }
      // tek parmak + zoom>1 → pan
      if(z.pointers.size===1 && z.scale>1){
        z.dragging = true; z.lx = e.clientX; z.ly = e.clientY;
        e.stopPropagation();
      }
    });

    container.addEventListener("pointermove", (e)=>{
      const z = getZoomState(index);
      if(z.pointers.has(e.pointerId)){
        z.pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
      }

      // Pinch (iki parmak)
      if(z.pointers.size===2){
        const [a,b] = Array.from(z.pointers.values());
        const dx = b.x - a.x, dy = b.y - a.y;
        const dist = Math.hypot(dx,dy);
        const deltaAbs = Math.abs(dist - z.baseDist);

        if(!z.pinching){
          if (deltaAbs >= PINCH_START_THRESHOLD){
            z.pinching = true;
            z.lastDist = dist;
            const rect = container.getBoundingClientRect();
            z.lastCx = (a.x + b.x)/2 - rect.left - rect.width/2 + z.tx;
            z.lastCy = (a.y + b.y)/2 - rect.top  - rect.height/2 + z.ty;
          } else {
            e.stopPropagation(); // pinch hazırlığı, swipe tetiklenmesin
            return;
          }
        }

        const delta = dist - (z.lastDist ?? dist);
        z.lastDist = dist;

        const prev = z.scale;
        const isOut = delta < 0;
        const divisor = isOut ? PINCH_DIV_OUT : PINCH_DIV_IN;
        const rawFactor = 1 + (delta / divisor);
        const cap       = isOut ? STEP_CAP_OUT : STEP_CAP_IN;
        const factor    = Math.min(Math.max(rawFactor, 1-cap), 1+cap);
        const next      = clamp(prev * factor, 1, 4);
        if(next !== prev){
          z.tx = z.lastCx - (z.lastCx - z.tx) * (next/prev);
          z.ty = z.lastCy - (z.lastCy - z.ty) * (next/prev);
          z.scale = next;
          apply(z); clampTranslate(z);
        }
        e.stopPropagation(); // pinch varken swipe yok
      }

      // Pan (tek parmak) — yalnız zoom>1
      if(z.dragging && z.scale>1){
        const dx = e.clientX - z.lx;
        const dy = e.clientY - z.ly;
        z.lx = e.clientX; z.ly = e.clientY;
        z.tx += dx; z.ty += dy;
        clampTranslate(z);
        e.stopPropagation();
      }
    });

    function endPointer(e){
      const z = getZoomState(index);
      if(z.pointers.has(e.pointerId)) z.pointers.delete(e.pointerId);
      if(z.pointers.size<2){ z.pinching = false; z.lastDist = null; }
      if(z.dragging){
        z.dragging = false;
        clampTranslate(z);
      }
      if(z.scale<=1.0001){ z.scale=1; z.tx=0; z.ty=0; apply(z); }
    }
    container.addEventListener("pointerup", endPointer);
    container.addEventListener("pointercancel", endPointer);
    container.addEventListener("pointerleave", endPointer);
  }

  // -------- init --------
  (async function init(){
    try{
      urls = await readManifest(manifestURL);
    }catch(e){
      urls = []; console.warn(e);
    }
    if(!urls.length){
      track.innerHTML = '<div class="slide"><div class="ph"></div></div>';
      counter.textContent = "0 / 0";
      btnPrev.disabled = btnNext.disabled = true;
      return;
    }
    buildSlides(urls);

    // İlk görseli hemen yükle (ilk ekranda boş kalmasın)
    const firstImg = track.querySelector(".slide .img");
    if(firstImg && !firstImg.dataset.loaded){
      firstImg.src = firstImg.dataset.src; firstImg.dataset.loaded="1";
      firstImg.addEventListener("load", ()=> firstImg.classList.add("ready"));
    }

    goTo(0,false); // hizala ve komşuları lazy-yükle
  })();
})();
</script>
</body>
</html>
